<!DOCTYPE html><html lang="en"><head ><title >Data Lifecycle</title><meta charset="UTF-8"/><link rel="stylesheet" type="text/css" href="lua-doc.css"/><script rel="stylesheet" type="text/javascript" src="lua-doc.js"></script></head><body ><div class="navigation-bar"><span class="navigation"><a href="index.html">Factorio</a> &raquo; Data Lifecycle</span><span class="version">Factorio 0.17.52</span></div><h1 >Data Lifecycle</h1><p ></p><p >
Factorio sorts mods first by dependencies then by natural sort order accounting for case (<a href="https://en.wikipedia.org/wiki/Natural_sort_order">https://en.wikipedia.org/wiki/Natural_sort_order</a>).</p><p >This describes the data flow for mods. In what order the different stages of data processing are done, what parts are available, and what&#x27;s expected during each stage.</p> <H2>1. The settings stage</h2> <p >When Factorio first starts, a single shared Lua state is created to process and collect mod setting prototype data from each mod into a global table named <code >data</code>. Additionally, a global table named <code >mods</code> exists that contains a mapping of mod name to mod version for all enabled mods.</p><p >First the settings.lua file is called for each mod. Next, the settings-updates.lua file is called for each mod and finally the settings-final-fixes.lua file is called for each mod. During this time there&#x27;s no game instance created and the standard Lua API is not available. The <code >data</code> table expects a specific format for each item in the table. Missing properties will either fall back to default values or give an error indicating what&#x27;s missing. Extra properties that the game isn&#x27;t looking for are simply ignored.</p><p >Changes made during each stage of the settings loading are automatically tracked and a history of which mod has changed which prototype is recorded by the game. After the settings stage of loading has finished, the Lua state is discarded. Changes and functions defined during the settings stage will not carry over to any other stages.</p><p >At the end of this stage all setting prototypes are constructed and the startup settings are read from the mods directory &quot;mod-settings.json&quot; file.</p> <h2>2. The data stage</h2> <p >Next, a new shared Lua state is created to process and collect all other prototype data from each mod into a new global table named <code >data</code>. The global table named <code >mods</code> still exists and a global table named &#x27;settings&#x27; is populated with all startup type mod setting values during this stage.</p><p >First the data.lua file is called for each mod. Next, the data-updates.lua file is called for each mod and finally the data-final-fixes.lua file is called for each mod. During this time there&#x27;s again no game instance created and the standard Lua API is not available. The <code >data</code> table expects a specific format for each item in the table. Missing properties will either fall back to default values or give an error indicating what&#x27;s missing. Extra properties that the game isn&#x27;t looking for are simply ignored.</p><p >Changes made during each stage of the data loading are automatically tracked and a history of which mod has changed which prototype is recorded by the game. After the data stage of loading has finished, the Lua state is discarded. Changes and functions defined during the data stage will not carry over to any other stages.</p><p >At the end of this stage, all prototypes are constructed and the game goes to the main menu.</p> <h2>3. control.lua initialization</h2> <p >During this stage, each mod&#x27;s control.lua is loaded and executed in their own Lua instance that will be owned by that mod for the remainder of the play session. Each mod has its own Lua instance and own <code >global</code> table to store data. Because this is run every time a save file is created or loaded you don&#x27;t need to restart the game to see changes made to the control.lua file. Simply restarting or reloading a save will re-run this stage.</p><p >During this stage access to the <code >global</code> table is not available. The <a href="LuaBootstrap.html"><code >script</code></a> table and the <a href="LuaRemote.html"><code >remote</code></a> table are however available. Note, although the <code >global</code> table has not been setup if a mod does populate the table with some data it will be overwritten by any loaded data.</p><p >At the end of this stage (if loading a save file) mod data saved in the map file is loaded and the <code >global</code> table for each mod is restored.</p> <h2>4. control.lua init </h2> <p >Using the mod order each mod is partially setup:</p><ul ><li > When creating a new game, <a href="LuaBootstrap.html#LuaBootstrap.on_init"><code >script.on_init()</code></a> will be called on each mod that has a control.lua file.</li><li > When loading a save game and the mod did not exist in that save game <a href="LuaBootstrap.html#LuaBootstrap.on_init"><code >script.on_init()</code></a> is called.</li><li > When loading a save game and the mod existed in that save game nothing is done in this stage.</li></ul><p >During the <a href="LuaBootstrap.html#LuaBootstrap.on_init"><code >script.on_init()</code></a> event handler access to the <code >game</code> table is available and any and all changes deemed necessary by the mod are free to be performed without risk of breaking anything.</p><p >Note: until on_init has finished executing for a given mod (scenario scripts are also counted as a mod) the game will not raise any game events for that mod.</p> <h2>5. Migrations</h2> <p >Migrations are a way to handle prototype changes and mod data structure changes between mod versions or game versions. Migrations do have access to the full game state. Migrations are each run in the mods Lua state. If a mod doesn&#x27;t have a control.lua the migration is run in a temporary Lua state that&#x27;s discarded after the migration has been applied.</p><p >See: <a href="Migrations.html"> Migrations</a></p> <h2>6. control.lua load </h2> <p >Using the mod order each mod that had data loaded has <a href="LuaBootstrap.html#LuaBootstrap.on_load"><code >script.on_load()</code></a> called.</p><p >During the <a href="LuaBootstrap.html#LuaBootstrap.on_load"><code >script.on_load()</code></a> event handler access to the <code >game</code> table is not available. This handler is meant for only 3 things:</p><ul ><li > 1. Re-setup meta-tables. Meta-tables are not persisted through save-load.</li><li > 2. Re-setup conditional event handlers (subscribing to an event only when some condition is true to save processing time).</li><li > 3. Create local references to data stored in the global table</li></ul><p >Attempting to change the contents of the <code >global</code> table during the <a href="LuaBootstrap.html#LuaBootstrap.on_load"><code >script.on_load()</code></a> event handler is not allowed. Doing so can lead to desyncs if the mod is used in multiplayer and will generate an error if the game detects it has been changed in any way.</p> <h2>7. control.lua <code>script.on_configuration_changed()</code></h2> <p >When mods are changed (prototypes added or removed), the major game version changes, a mod version changes, a mod is removed, or a mod is added the <a href="LuaBootstrap.html#LuaBootstrap.on_configuration_changed"><code >script.on_configuration_changed()</code></a> event is fired for each mod subscribed to that event.</p><p >This is the main place for handling mod internal data structure changes. Access to the <code >global</code> table, <code >game</code> table and game state are available and can be changed in any way seen fit by the mod.</p><p >Note: this is not the place to handle things such as recipe unlocks due to research changes - that is best done through migration scripts.</p> <h2>8. control.lua runtime:</h2> <p >At this stage the game is running fully and everything has been setup or loaded. Access to all tables is available in any event handler.
</p><div class="brief-listing"></div></body></html>